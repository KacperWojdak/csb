# -*- coding: utf-8 -*-
"""Nueman.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1R6n3oyy_QZkGNPhdPimv_qIAXm2seD1y
"""

import matplotlib.pyplot as plt
import numpy as np

def middle_square(seed, iterations):
    if seed <= 0 or iterations <= 0:
        raise ValueError("Seed and iterations must be positive integers")

    num_digits = len(str(seed))
    results = []

    # Set to store seen seeds
    seen_seeds = set()

    for _ in range(iterations):
        square = seed ** 2
        square_str = str(square).zfill(2 * num_digits)
        middle = int(square_str[(len(square_str) - num_digits) // 2 : (len(square_str) + num_digits) // 2])

        # If the seed repeats, break the loop
        if seed in seen_seeds:
            print(f"Seed {seed} is repeated. The following results may be repeated.")
            break
        else:
            seen_seeds.add(seed)

        results.append((seed, middle, square))
        seed = middle

    return results

def print_results(results):
    for i, (seed, middle, square) in enumerate(results):
        print(f'x{i+1}\t {square:<20} {middle}')

def plot_results(results):
    x_values = [i for i in range(len(results) - 1)]
    normalized_results = [middle / 10000 for _, middle, _ in results[:-1]]

    # Plotting the points with normalized values
    plt.scatter(x_values, normalized_results, c='blue', label='Punkty (xi, xi+1)')
    plt.xlabel('Iteracja')
    plt.ylabel('Znormalizowana wartość środkowa')
    plt.title('Wykres punktowy wyników algorytmu middle square')

    # Obliczamy całkę od 0 do 1 z e^-x^2
    x = np.linspace(0, 1, 1000)  # Zakres od 0 do 1
    y = np.exp(-x**2)  # Funkcja e^-x^2
    integral = np.trapz(y, x)  # Obliczamy całkę numerycznie

    print("Wartość całki od 0 do 1 z e^-x^2:", integral)

    plt.legend()
    plt.show()

results = middle_square(1211, 100)
print_results(results)
plot_results(results)

# Testing the function with an 8-digit seed
results = middle_square(12345678, 200)
print_results(results)
plot_results(results)

import numpy as np

def middle_square(seed, iterations):
    if seed <= 0 or iterations <= 0:
        raise ValueError("Seed and iterations must be positive integers")

    num_digits = len(str(seed))
    results = []

    # Set to store seen seeds
    seen_seeds = set()

    for _ in range(iterations):
        square = seed ** 2
        square_str = str(square).zfill(2 * num_digits)
        middle = int(square_str[(len(square_str) - num_digits) // 2 : (len(square_str) + num_digits) // 2])

        # If the seed repeats, break the loop
        if seed in seen_seeds:
            print(f"Seed {seed} is repeated. The following results may be repeated.")
            break
        else:
            seen_seeds.add(seed)

        results.append((seed, middle, square))
        seed = middle

    return results

def transform_data(X, a, b):
    return a * np.array(X) + b

# Run middle square algorithm to generate random numbers
results = middle_square(1211, 90)

# Extract the generated numbers
generated_numbers = [middle / 10000 for _, middle, _ in results]

# Parameters for transformation
a = 2
b = 5

# Transform the generated numbers
transformed_numbers = transform_data(generated_numbers, a, b)

# Calculate variance
var_X = np.var(generated_numbers)
var_Y = np.var(transformed_numbers)
var_Y_expected = a**2 * var_X

print(f"var_X = {var_X} \nvar_Y = {var_Y} \nvar_Y_expected = {var_Y_expected}")
if var_Y-var_Y_expected==0:
  print("var(aX + b) = a**2 * var(X)")

import numpy as np

def middle_square(seed, iterations):
    if seed <= 0 or iterations <= 0:
        raise ValueError("Seed and iterations must be positive integers")

    num_digits = len(str(seed))
    results = []
    poisson_samples = []

    # Set to store seen seeds
    seen_seeds = set()

    for _ in range(iterations):
        square = seed ** 2
        square_str = str(square).zfill(2 * num_digits)
        middle = int(square_str[(len(square_str) - num_digits) // 2 : (len(square_str) + num_digits) // 2])

        # If the seed repeats, break the loop
        if seed in seen_seeds:
            print(f"Seed {seed} is repeated. The following results may be repeated.")
            break
        else:
            seen_seeds.add(seed)

        results.append((seed, middle, square))
        seed = middle

        # Generowanie próbki z rozkładu Poissona na podstawie kwadratu środkowego
        poisson_sample = np.random.poisson(middle)
        poisson_samples.append(poisson_sample)

    return results, poisson_samples

import numpy as np

def simulate_insurance_company(initial_capital, claim_rate, claim_mean, payment_rate, days):
    positive_capital_count = 0

    for _ in range(1000):
        capital = initial_capital
        for _ in range(days):
            claims = np.random.poisson(claim_rate)
            total_claims = np.random.exponential(scale=claim_mean, size=claims).sum()
            total_payments = payment_rate
            capital += total_payments - total_claims
            if capital <= 0:
                break
        if capital > 0:
            positive_capital_count += 1

    return positive_capital_count / 1000

initial_capital = 25000
claim_rate = 10
claim_mean = 1000
payment_rate = 11000
days = 365

probability_positive_capital = simulate_insurance_company(initial_capital, claim_rate, claim_mean, payment_rate, days)
print(f"Prawdopodobieństwo, że kapitał będzie zawsze dodatni przez pierwszych {days} dni:", probability_positive_capital)

import numpy as np

def simulate_insurance_company(initial_capital, claim_rate, claim_mean, payment_rate, days):
    positive_capital_count = 0

    for _ in range(simulations):
        capital = initial_capital
        print("Dzień 0: Kapitał początkowy =", capital)
        print("------",_,"------")
        for day in range(1, days + 1):
            claims = np.random.poisson(claim_rate)
            total_claims = np.random.exponential(scale=claim_mean, size=claims).sum()
            capital += payment_rate - total_claims
            print(f"Dzień {day}: Kapitał =", capital)
            print(f"Klienci w dniu {claims}")
            print(f"Pobrano w dniu {total_claims}")
            if capital <= 0:
                print(f"Bankructwo w dniu {day}")
                break
        if capital > 0:
            positive_capital_count += 1
            print("Kapitał pozostaje dodatni przez cały okres.")
        else:
            print("Kapitał spadł poniżej zera.")
        print("------------------------------------------------------------------------")

    return positive_capital_count / simulations

initial_capital = 25000
claim_rate = 10
claim_mean = 1000
payment_rate = 11000
days = 365
simulations = 100

probability_positive_capital = simulate_insurance_company(initial_capital, claim_rate, claim_mean, payment_rate, days)
print(f"Prawdopodobieństwo, że kapitał będzie zawsze dodatni przez pierwszych {days} dni:", probability_positive_capital)

import numpy as np

# Parametry symulacji
initial_capital = 25000
claim_rate = 10
claim_mean = 1000
payment_rate = 11000
days = 365
simulations = 100

def my_poisson(rate):
    # Generowanie liczby z rozkładu Poissona
    k = 0
    p = 1.0
    L = np.exp(-rate)
    while p > L:
        k += 1
        u = np.random.random()
        p *= u
    return k - 1

def simulate_insurance_company(initial_capital, claim_rate, claim_mean, payment_rate, days):
    positive_capital_count = 0

    for _ in range(simulations):
        capital = initial_capital
        print("Dzień 0: Kapitał początkowy =", capital)
        print("------",_,"------")
        for day in range(1, days + 1):
            claims = my_poisson(claim_rate)
            total_claims = np.random.exponential(scale=claim_mean, size=claims).sum()
            capital += payment_rate - total_claims
            print(f"Dzień {day}: Kapitał =", capital)
            print(f"Klienci w dniu {claims}")
            print(f"Pobrano w dniu {total_claims}")
            if capital <= 0:
                print(f"Bankructwo w dniu {day}")
                break
        if capital > 0:
            positive_capital_count += 1
            print("Kapitał pozostaje dodatni przez cały okres.")
        else:
            print("Kapitał spadł poniżej zera.")
        print("------")

    return positive_capital_count / simulations

probability_positive_capital = simulate_insurance_company(initial_capital, claim_rate, claim_mean, payment_rate, days)
print(f"Prawdopodobieństwo, że kapitał będzie zawsze dodatni przez pierwszych {days} dni:", probability_positive_capital)

# Parametry symulacji
kapital_poczatkowy = 25000
stawka_przychodu_dziennego = 11000
tempo_roszczen = 10  # roszczenia na dzień
srednia_kwota_roszczenia = 1000
liczba_dni = 365
liczba_symulacji = 1000

# Liniowy generator kongruencyjny
class LCG:
    def __init__(self, seed, a=1664525, c=1013904223, m=2**32):
        self.seed = seed
        self.a = a
        self.c = c
        self.m = m

    def random(self):
        self.seed = (self.a * self.seed + self.c) % self.m
        return self.seed / self.m

def symuluj_rok(seed2):
    generator = LCG(seed=seed2)  # Inicjalizacja generatora liczb losowych
    kapital = kapital_poczatkowy
    for dzien in range(liczba_dni):
        # Generowanie liczby roszczeń dla danego dnia
        liczba_roszczen = int(generator.random() * tempo_roszczen)  # Użycie generatora do wygenerowania liczby roszczeń
        # Suma roszczeń dla danego dnia
        roszczenia = sum(generator.random() * srednia_kwota_roszczenia for _ in range(liczba_roszczen))  # Użycie generatora do wygenerowania kwoty roszczeń
        # Aktualizacja kapitału
        kapital += stawka_przychodu_dziennego - roszczenia
        # Sprawdzenie, czy kapitał jest dodatni
        if kapital < 0:
            return False  # kapitał spadł poniżej zera
    return True  # kapitał pozostał dodatni przez cały rok

# Symulacja wielokrotna
wyniki = [symuluj_rok(_+1) for _ in range(liczba_symulacji)]
prawdopodobienstwo = sum(wynik for wynik in wyniki) / liczba_symulacji
print(f'Prawdopodobieństwo, że kapitał będzie dodatni przez 365 dni wynosi: {prawdopodobienstwo:.4f}')